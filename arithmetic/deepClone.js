// deepClone todo
// 思考： deepClone的目的，为了避免 新对象的改变触发老对象的改变
// 思考：什么情况下，改了新的对象，老得对象也会被改掉
// 答：说明两个指针只像同一个对象，并且改的是对象的属性
// （ps: 如果改的是对象的指，老的指针指向的还是老的值，新的指向新的值，不会影响到老的， 只能是指针指向了同一个对象，并且改了对象里面的属性, 
//  这一点很重要，意味着我copy一个对象的时候，如果他的值不是一个更深入的键值对，我只有返回当前值就好了
//  如：
//  var a = { name: 111, setName: fuction() {} }
//  var b = { name: a.name, setName: b.setName }
//  b.setName = 12345
//  console.log(a.setName) ===> function () {}
//  所以我在copy一个对象的时候，只要新建一个object, 非复杂对象 只要 复制键值对就好了
/*   ┌──────────────────────────────────────────────────────────────────────────┐
 *   │var a = { name: 111, setName: function(){} }                              │
 *   │var b = a                                                                 │
 *   │var c = { name: a.name, setName: a.setName }                              │
 *   └──────────────────────────────────────────────────────────────────────────┘
 *   ┌───────────┐             ┌────────────────────────────────────────────────┐
 *   │   stack   │             │                      heap                      │
 *   └───────────┘             └────────────────────────────────────────────────┘
 *   ┌───────────┐             ┌────────────────────────────────────────────────┐
 *   │           │             │┌───────────────┐                               │
 *   │           │             ││     stack     │                               │
 *   │           │             │└───────────────┘                               │
 *   │           │             │┌───────────────┐                               │
 *   │┌─────────┐│             ││ ┌────────────┐│                               │
 *   ││ a: add──┼┼─────────────┼▶ │ name: 111  ││         ┌──────────────────┐  │
 *   │└─────────┘│             ││ └────────────┘│         │                  │  │
 *   │           │             ││ ┌───────────┐ │         │                  │  │
 *   │┌─────────┐│             ││ │ setName:  │ │         │  function () {}  │  │
 *   ││ b: addr ├┼─────────────┼▶ │   addr    ├─┼─────────▶                  │  │
 *   │└─────────┘│             ││ └───────────┘ │         │                  │  │
 *   │           │             ││               │         │                  │  │
 *   │           │             │└───────────────┘         └──────────────────┘  │
 *   │           │             │┌───────────────┐                   ▲           │
 *   │┌─────────┐│             ││ ┌───────────┐ │                   │           │
 *   ││ c: add──┼┼─────────────┼▶ │ name: 111 │ │                   │           │
 *   │└─────────┘│             ││ └───────────┘ │                   │           │
 *   │           │             ││ ┌───────────┐ │                   │           │
 *   │           │             ││ │ setName:  │ │                   │           │
 *   │           │             ││ │   addr    │─┼───────────────────┘           │
 *   │           │             ││ └───────────┘ │                               │
 *   │           │             │└───────────────┘                               │
 *   └───────────┘             └────────────────────────────────────────────────┘
 */                                                                                                                                       
// 基于以上，拆分任务
// 1、基础类型 string number boolean undefinded null symbol 直接返回，保存在stack里面的
// 2、object                                       
// 内存角度
// 基本类型属于栈内存（名义上），直接返回就会创建新的
// 引用类型：直接返回是个地址，肯定不行，需要遍历进行继续copy
// js 类型
// 基本类型  string number boolean undefinded null symbol
// 复杂类型 object：
// 特殊对象： array，date, RegExp，function，Map，Set
// 

function isObject(target) {
  return target !== null && typeof target === 'object'
}

function isFunction(target) {
  return typeof target !== 'function'
}

function isArray(target) {
  return Array.isArray(target)
}

function deepClone(target) {

  if (isFunction(target)) {
    return null
  }

  if (!isObject) {

  }
}